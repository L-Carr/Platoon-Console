from django.contrib.auth.models import Group
from rest_framework import status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny
from rest_framework.authtoken.models import Token

from django.contrib.auth import authenticate, login
from django.contrib.auth import get_user_model
from .serializers import UserSerializer,LoginSerializer
from .utils import single_email_distro
from django.contrib.auth import get_user_model
from django.contrib.auth.tokens import default_token_generator
from .models import UserAccount
from django.urls import reverse
from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
from django.utils.encoding import force_bytes, force_str

class UserRegistration(APIView):
    # AllowAny: This permission class allows any user to access this view,
    # regardless of whether they are authenticated or not.
    permission_classes = [AllowAny]

    def post(self, request):
        # This method handles POST requests to register new users.

        # The data from the request is passed to the UserSerializer to validate and serialize.
        serializer = UserSerializer(data=request.data)
        
        # Check if the data provided by the client is valid according to the serializer.
        if serializer.is_valid():
            # If data is valid, save the user to the database using the serializer's save method.
            user = serializer.save()

            # Retrieve the 'Students' group. It's assumed that this group already exists in the database.
            group = Group.objects.get(name='Students')

            # Add the newly created user to the 'Students' group.
            user.groups.add(group)
            # Save any changes to the user instance.
            user.save()

            # Create or retrieve an authentication token for the newly registered user.
            token, created = Token.objects.get_or_create(user=user)
            if token:
                #single_email_distro(recipient_email, email_subject,email_greeting, email_body):
                single_email_distro(user.email,"Platoon.Console Registration","Welcome to Platoon.Console,","Thank you for registering with Platoon.Console. We hope you enjoy Code Platoon as much as we did.")
            
            # Return a success response to the client, with a message indicating registration was successful.
                return Response({'message': 'User registered.'}, status=status.HTTP_201_CREATED)
        else:
            # If the data is not valid, return a 400 Bad Request response,
            # including the error messages generated by the serializer.
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class UserPasswordReset(APIView):
    def post(self, request):
        # Get the user's email from the request
        email = request.data.get('email')
        user = get_user_model()
        try:
            user = user.objects.get(email=email)
            # Generate token
            token = default_token_generator.make_token(user)
            uidb64 = urlsafe_base64_encode(force_bytes(user.pk))
            # Create link
            link = request.build_absolute_uri(
                reverse('password-reset-confirm', kwargs={'uidb64': uidb64, 'token': token})
            )
            # Send email
            # send_mail(
            #     'Password Reset',
            #     f'Please use the following link to reset your password: {link}',
            #     'noreply@example.com',
            #     [email],
            #     fail_silently=False,
            # )
                            #single_email_distro(recipient_email, email_subject,email_greeting, email_body):
            single_email_distro(email,"Platoon.Console Password Reset","You've reached Platoon.Console Support,",f"You have requested a password reset. Please click the link below to reset your password. If you did not request this, please ignore this email. {link}")

            return Response({'message': 'Password reset email sent.'}, status=status.HTTP_200_OK)
        except user.DoesNotExist:
            return Response({'error': 'User does not exist.'}, status=status.HTTP_404_NOT_FOUND)

    def put(self, request, uidb64, token):
        try:
            uid = force_str(urlsafe_base64_decode(uidb64))
            user = get_user_model().objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, user.DoesNotExist):
            return Response({'error': 'Invalid link'}, status=status.HTTP_400_BAD_REQUEST)

        if user is not None and default_token_generator.check_token(user, token):
            new_password = request.data.get('new_password')
            user.set_password(new_password)
            user.save()
            return Response({'message': 'Password has been reset.'}, status=status.HTTP_200_OK)
        
        return Response({'error': 'Invalid token'}, status=status.HTTP_400_BAD_REQUEST)

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework import status
from rest_framework.authtoken.models import Token
from django.contrib.auth import authenticate, login

from .serializers import LoginSerializer
from .models import UserAccount

class UserLogin(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        """
        Logs in a user and returns an authentication token.
        """
        serializer = LoginSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        username = serializer.validated_data['username']
        password = serializer.validated_data['password']
        user = authenticate(username=username, password=password)

        if not user:
            return Response({'error': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)

        # Retrieve or create a user profile
        try:
            user_profile = UserAccount.objects.get(user=user)
        except UserAccount.DoesNotExist:
            return Response({'error': 'User not found'}, status=status.HTTP_404_NOT_FOUND)

        # Retrieve or create a token for the authenticated user
        token, _ = Token.objects.get_or_create(user=user)
        
        # Log the user in (start session)
        login(request, user)

        return Response({'token': token.key}, status=status.HTTP_200_OK)

